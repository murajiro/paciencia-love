import React, { useState, useEffect } from 'react';
import { RotateCcw, Trophy, Clock, Heart, Sparkles } from 'lucide-react';

const SUITS = ['â™¥', 'â™¦', 'â™£', 'â™ '];
const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
const DIFFICULTIES = {
  easy: { name: 'FÃ¡cil', draw: 1, desc: 'Perfeito para comeÃ§ar' },
  medium: { name: 'MÃ©dio', draw: 3, desc: 'Um desafio equilibrado' },
  hard: { name: 'DifÃ­cil', draw: 3, desc: 'Para mestres da paciÃªncia' }
};

// Fotos personalizadas - caminho relativo para as imagens
const PHOTOS = {
  jack: './images/jack.jpg',        // Foto 1 - VocÃª (Valete)
  queen: './images/queen.jpg',      // Foto 7 - Alanna de preto (Rainha)
  king: './images/king.jpg',        // Foto 6 - VocÃªs dois juntos (Rei)
  hearts: './images/hearts.jpg',    // Foto 2 - Alanna com flor (Copas â™¥)
  diamonds: './images/diamonds.jpg',// Foto 3 - Alanna camisa branca (Ouros â™¦)
  clubs: './images/clubs.jpg',      // Foto 4 - Alanna com ursinhos (Paus â™£)
  spades: './images/spades.jpg'     // Foto 5 - Alanna de biquÃ­ni (Espadas â™ )
};

const createDeck = () => {
  const deck = [];
  SUITS.forEach(suit => {
    RANKS.forEach((rank, i) => {
      deck.push({
        suit,
        rank,
        value: i + 1,
        color: (suit === 'â™¥' || suit === 'â™¦') ? 'red' : 'black',
        id: `${suit}-${rank}`
      });
    });
  });
  return deck;
};

const shuffleDeck = (deck) => {
  const shuffled = [...deck];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
};

export default function SolitaireGame() {
  const [gameState, setGameState] = useState('menu');
  const [difficulty, setDifficulty] = useState('easy');
  const [tableau, setTableau] = useState([]);
  const [foundations, setFoundations] = useState([[], [], [], []]);
  const [stock, setStock] = useState([]);
  const [waste, setWaste] = useState([]);
  const [selectedCard, setSelectedCard] = useState(null);
  const [score, setScore] = useState(0);
  const [moves, setMoves] = useState(0);
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    let interval;
    if (isRunning) {
      interval = setInterval(() => {
        setTime(t => t + 1);
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [isRunning]);

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const startGame = (diff) => {
    setDifficulty(diff);
    const deck = shuffleDeck(createDeck());
    
    const newTableau = [[], [], [], [], [], [], []];
    let deckIndex = 0;
    
    for (let col = 0; col < 7; col++) {
      for (let row = 0; row <= col; row++) {
        newTableau[col].push({
          ...deck[deckIndex],
          faceUp: row === col
        });
        deckIndex++;
      }
    }
    
    setTableau(newTableau);
    setFoundations([[], [], [], []]);
    setStock(deck.slice(deckIndex));
    setWaste([]);
    setSelectedCard(null);
    setScore(0);
    setMoves(0);
    setTime(0);
    setIsRunning(true);
    setGameState('playing');
  };

  const drawFromStock = () => {
    const drawCount = DIFFICULTIES[difficulty].draw;
    
    if (stock.length === 0) {
      setStock([...waste].reverse());
      setWaste([]);
      return;
    }

    const drawn = stock.slice(0, Math.min(drawCount, stock.length));
    setWaste([...waste, ...drawn]);
    setStock(stock.slice(drawn.length));
    setMoves(m => m + 1);
  };

  const canPlaceOnFoundation = (card, foundation) => {
    if (foundation.length === 0) {
      return card.rank === 'A';
    }
    const topCard = foundation[foundation.length - 1];
    return card.suit === topCard.suit && card.value === topCard.value + 1;
  };

  const canPlaceOnTableau = (card, column) => {
    if (column.length === 0) {
      return card.rank === 'K';
    }
    const topCard = column[column.length - 1];
    return topCard.faceUp && card.color !== topCard.color && card.value === topCard.value - 1;
  };

  const moveToFoundation = (card, fromLocation) => {
    // Mapear cada naipe para sua fundaÃ§Ã£o especÃ­fica
    const suitToFoundation = { 'â™¥': 0, 'â™¦': 1, 'â™£': 2, 'â™ ': 3 };
    const foundationIndex = suitToFoundation[card.suit];
    const foundation = foundations[foundationIndex];

    // Verificar se pode colocar nesta fundaÃ§Ã£o
    if (!canPlaceOnFoundation(card, foundation)) {
      return false;
    }

    const newFoundations = [...foundations];
    newFoundations[foundationIndex] = [...newFoundations[foundationIndex], card];
    setFoundations(newFoundations);

      if (fromLocation.type === 'waste') {
        setWaste(waste.slice(0, -1));
      } else if (fromLocation.type === 'tableau') {
        const newTableau = [...tableau];
        newTableau[fromLocation.column] = newTableau[fromLocation.column].slice(0, -1);
        if (newTableau[fromLocation.column].length > 0) {
          newTableau[fromLocation.column][newTableau[fromLocation.column].length - 1].faceUp = true;
        }
        setTableau(newTableau);
      }

      setScore(s => s + 10);
      setMoves(m => m + 1);
      setSelectedCard(null);

    if (newFoundations.every(f => f.length === 13)) {
      setIsRunning(false);
      setGameState('won');
    }
    return true;
  };

  const handleCardClick = (card, location) => {
    if (!card.faceUp) return;

    if (selectedCard) {
      if (selectedCard.location.type === 'waste' || selectedCard.location.type === 'tableau') {
        if (location.type === 'tableau') {
          const column = tableau[location.column];
          if (canPlaceOnTableau(selectedCard.card, column)) {
            const newTableau = [...tableau];
            
            if (selectedCard.location.type === 'waste') {
              newTableau[location.column] = [...newTableau[location.column], { ...selectedCard.card, faceUp: true }];
              setWaste(waste.slice(0, -1));
            } else {
              const fromCol = selectedCard.location.column;
              const cardIndex = newTableau[fromCol].findIndex(c => c.id === selectedCard.card.id);
              const cardsToMove = newTableau[fromCol].slice(cardIndex);
              newTableau[location.column] = [...newTableau[location.column], ...cardsToMove];
              newTableau[fromCol] = newTableau[fromCol].slice(0, cardIndex);
              
              if (newTableau[fromCol].length > 0) {
                newTableau[fromCol][newTableau[fromCol].length - 1].faceUp = true;
              }
            }
            
            setTableau(newTableau);
            setScore(s => s + 5);
            setMoves(m => m + 1);
            setSelectedCard(null);
            return;
          }
        }
      }
      setSelectedCard(null);
    } else {
      setSelectedCard({ card, location });
    }
  };

  const handleFoundationClick = (index) => {
    if (selectedCard) {
      moveToFoundation(selectedCard.card, selectedCard.location);
    }
  };

  const handleEmptyTableauClick = (colIndex) => {
    if (selectedCard && selectedCard.card.rank === 'K') {
      const newTableau = [...tableau];
      
      if (selectedCard.location.type === 'waste') {
        newTableau[colIndex] = [{ ...selectedCard.card, faceUp: true }];
        setWaste(waste.slice(0, -1));
      } else if (selectedCard.location.type === 'tableau') {
        const fromCol = selectedCard.location.column;
        const cardIndex = newTableau[fromCol].findIndex(c => c.id === selectedCard.card.id);
        const cardsToMove = newTableau[fromCol].slice(cardIndex);
        newTableau[colIndex] = cardsToMove;
        newTableau[fromCol] = newTableau[fromCol].slice(0, cardIndex);
        
        if (newTableau[fromCol].length > 0) {
          newTableau[fromCol][newTableau[fromCol].length - 1].faceUp = true;
        }
      }
      
      setTableau(newTableau);
      setScore(s => s + 5);
      setMoves(m => m + 1);
      setSelectedCard(null);
    }
  };

  const Card = ({ card, onClick, isSelected, style = {} }) => {
    const isRed = card.color === 'red';
    
    // Determinar qual foto usar
    const getCardPhoto = () => {
      if (card.rank === 'J') return PHOTOS.jack;
      if (card.rank === 'Q') return PHOTOS.queen;
      if (card.rank === 'K') return PHOTOS.king;
      
      const suitMap = { 'â™¥': 'hearts', 'â™¦': 'diamonds', 'â™£': 'clubs', 'â™ ': 'spades' };
      return PHOTOS[suitMap[card.suit]];
    };

    const shouldShowPhoto = card.faceUp && (card.rank === 'J' || card.rank === 'Q' || card.rank === 'K');
    const photo = shouldShowPhoto ? getCardPhoto() : null;
    
    return (
      <div
        onClick={onClick}
        className={`relative w-20 h-28 rounded-lg flex flex-col items-center justify-center text-sm font-bold cursor-pointer transition-all shadow-md overflow-hidden ${
          card.faceUp
            ? `bg-white ${isRed ? 'text-red-500' : 'text-gray-800'} ${
                isSelected ? 'border-4 border-pink-400 shadow-xl scale-105 ring-2 ring-pink-300' : 'border-2 border-gray-300'
              }`
            : 'bg-gradient-to-br from-purple-600 via-pink-600 to-rose-600 border-2 border-pink-400'
        }`}
        style={style}
      >
        {card.faceUp ? (
          <>
            {photo ? (
              <>
                <img 
                  src={photo} 
                  alt={card.rank}
                  className="absolute inset-0 w-full h-full object-cover"
                />
                <div className="absolute top-1 left-1 bg-white bg-opacity-90 rounded px-1.5 py-0.5 text-xs font-bold shadow-sm">
                  {card.rank}
                </div>
                <div className={`absolute top-1 right-1 bg-white bg-opacity-90 rounded px-1 py-0.5 text-base shadow-sm ${isRed ? 'text-red-500' : 'text-gray-800'}`}>
                  {card.suit}
                </div>
              </>
            ) : (
              <>
                <div className="text-xl font-bold">{card.rank}</div>
                <div className="text-2xl">{card.suit}</div>
              </>
            )}
          </>
        ) : (
          <div className="w-full h-full flex items-center justify-center">
            <div className="text-white opacity-30 text-3xl">âœ¦</div>
          </div>
        )}
      </div>
    );
  };

  if (gameState === 'menu') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-rose-400 via-pink-400 to-purple-500 flex items-center justify-center p-4">
        <div className="absolute inset-0 overflow-hidden pointer-events-none">
          <div className="absolute top-20 left-10 text-6xl opacity-10">â™¥</div>
          <div className="absolute top-40 right-20 text-5xl opacity-10">â™¦</div>
          <div className="absolute bottom-32 left-20 text-7xl opacity-10">â™ </div>
          <div className="absolute bottom-20 right-32 text-6xl opacity-10">â™£</div>
        </div>
        
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full relative z-10">
          <div className="text-center mb-8">
            <Sparkles className="w-12 h-12 mx-auto mb-3 text-pink-500" />
            <h1 className="text-5xl font-bold mb-2 bg-gradient-to-r from-pink-500 via-rose-500 to-purple-500 bg-clip-text text-transparent">
              PaciÃªncia
            </h1>
            <div className="flex items-center justify-center gap-2 mb-1">
              <Heart className="w-5 h-5 text-rose-500 fill-rose-500" />
              <p className="text-2xl font-semibold text-gray-700">Alanna</p>
              <Heart className="w-5 h-5 text-rose-500 fill-rose-500" />
            </div>
            <p className="text-sm text-gray-500 italic">Feito especialmente para vocÃª</p>
          </div>
          
          <div className="space-y-3">
            <h2 className="text-lg font-semibold text-gray-700 text-center mb-4">
              Escolha sua dificuldade
            </h2>
            
            {Object.entries(DIFFICULTIES).map(([key, { name, desc }]) => (
              <button
                key={key}
                onClick={() => startGame(key)}
                className="w-full bg-gradient-to-r from-pink-500 to-rose-500 hover:from-pink-600 hover:to-rose-600 text-white font-semibold py-4 px-6 rounded-xl transition-all transform hover:scale-105 shadow-lg hover:shadow-xl"
              >
                <div className="text-lg">{name}</div>
                <div className="text-xs opacity-90">{desc}</div>
              </button>
            ))}
          </div>
          
          <div className="mt-6 text-center text-xs text-gray-400">
            â™¥ Toque nas cartas para jogar â™¥
          </div>
        </div>
      </div>
    );
  }

  if (gameState === 'won') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-yellow-400 via-orange-400 to-pink-500 flex items-center justify-center p-4">
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center">
          <Trophy className="w-28 h-28 mx-auto mb-4 text-yellow-500 animate-bounce" />
          <h1 className="text-5xl font-bold mb-2 bg-gradient-to-r from-yellow-500 to-orange-500 bg-clip-text text-transparent">
            ParabÃ©ns!
          </h1>
          <p className="text-3xl mb-2">ðŸŽ‰</p>
          <p className="text-xl mb-6 text-gray-600 font-semibold">Alanna, vocÃª arrasou!</p>
          
          <div className="bg-gradient-to-r from-pink-50 to-purple-50 rounded-2xl p-5 mb-6 space-y-3">
            <div className="text-lg">
              <span className="font-semibold text-gray-700">PontuaÃ§Ã£o:</span>{' '}
              <span className="text-pink-600 font-bold text-xl">{score}</span>
            </div>
            <div className="text-lg">
              <span className="font-semibold text-gray-700">Movimentos:</span>{' '}
              <span className="text-purple-600 font-bold text-xl">{moves}</span>
            </div>
            <div className="text-lg">
              <span className="font-semibold text-gray-700">Tempo:</span>{' '}
              <span className="text-rose-600 font-bold text-xl">{formatTime(time)}</span>
            </div>
          </div>

          <button
            onClick={() => setGameState('menu')}
            className="w-full bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white font-semibold py-4 px-6 rounded-xl transition-all transform hover:scale-105 shadow-lg"
          >
            Jogar Novamente
          </button>
        </div>
      </div>
    );
  }

  const foundationSuits = ['â™¥', 'â™¦', 'â™£', 'â™ '];

  return (
    <div className="min-h-screen bg-gradient-to-br from-rose-300 via-pink-300 to-purple-400 p-3 overflow-x-hidden">
      <div className="max-w-4xl mx-auto">
        <div className="bg-white bg-opacity-90 backdrop-blur rounded-2xl shadow-lg p-4 mb-4">
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              <Heart className="w-5 h-5 text-rose-500 fill-rose-500" />
              <span className="font-bold text-lg text-gray-800">Alanna</span>
            </div>
            
            <div className="flex items-center gap-4 text-sm">
              <div className="flex items-center gap-1 bg-blue-50 px-3 py-1 rounded-lg">
                <Clock className="w-4 h-4 text-blue-600" />
                <span className="font-semibold text-blue-600">{formatTime(time)}</span>
              </div>
              <div className="flex items-center gap-1 bg-yellow-50 px-3 py-1 rounded-lg">
                <Trophy className="w-4 h-4 text-yellow-600" />
                <span className="font-semibold text-yellow-600">{score}</span>
              </div>
              <div className="bg-purple-50 px-3 py-1 rounded-lg">
                <span className="font-semibold text-purple-600">{moves} movimentos</span>
              </div>
            </div>
            
            <button
              onClick={() => setGameState('menu')}
              className="bg-gradient-to-r from-pink-500 to-rose-500 hover:from-pink-600 hover:to-rose-600 text-white px-4 py-2 rounded-xl flex items-center gap-2 transition-all transform hover:scale-105 shadow-md"
            >
              <RotateCcw className="w-4 h-4" />
              <span className="font-semibold">Menu</span>
            </button>
          </div>
        </div>

        <div className="bg-white bg-opacity-80 backdrop-blur rounded-2xl shadow-lg p-4 mb-4">
          <div className="flex justify-between">
            <div className="flex gap-3">
              <div
                onClick={drawFromStock}
                className="w-20 h-28 rounded-lg border-3 border-pink-400 bg-gradient-to-br from-purple-600 via-pink-600 to-rose-600 flex items-center justify-center cursor-pointer hover:scale-105 transition-transform shadow-md"
              >
                {stock.length > 0 && (
                  <div className="text-white font-bold text-lg">{stock.length}</div>
                )}
              </div>
              
              <div className="w-20 h-28 rounded-lg border-2 border-dashed border-pink-300 bg-pink-50 flex items-center justify-center">
                {waste.length > 0 && (
                  <Card
                    card={waste[waste.length - 1]}
                    onClick={() => handleCardClick(waste[waste.length - 1], { type: 'waste' })}
                    isSelected={selectedCard?.card.id === waste[waste.length - 1].id}
                  />
                )}
              </div>
            </div>

            <div className="flex gap-3">
              {foundations.map((foundation, i) => (
                <div
                  key={i}
                  onClick={() => handleFoundationClick(i)}
                  className="w-20 h-28 rounded-lg border-2 border-pink-300 bg-gradient-to-br from-pink-50 to-purple-50 flex flex-col items-center justify-center cursor-pointer hover:border-pink-400 transition-all shadow-sm"
                >
                  {foundation.length > 0 ? (
                    <Card card={foundation[foundation.length - 1]} onClick={() => {}} />
                  ) : (
                    <div className={`text-4xl opacity-20 ${
                      foundationSuits[i] === 'â™¥' || foundationSuits[i] === 'â™¦' 
                        ? 'text-red-400' 
                        : 'text-gray-600'
                    }`}>
                      {foundationSuits[i]}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        </div>

        <div className="bg-white bg-opacity-80 backdrop-blur rounded-2xl shadow-lg p-4">
          <div className="flex gap-2 overflow-x-auto pb-4">
            {tableau.map((column, colIndex) => (
              <div key={colIndex} className="flex-shrink-0" style={{ width: '5rem' }}>
                <div
                  onClick={() => column.length === 0 && handleEmptyTableauClick(colIndex)}
                  className="w-20 h-28 rounded-lg border-2 border-dashed border-pink-200 bg-pink-50 mb-1 cursor-pointer hover:border-pink-300 transition-colors"
                />
                {column.map((card, cardIndex) => (
                  <div
                    key={card.id}
                    style={{ marginTop: cardIndex === 0 ? '-7.25rem' : '-5.25rem' }}
                  >
                    <Card
                      card={card}
                      onClick={() => handleCardClick(card, { type: 'tableau', column: colIndex })}
                      isSelected={selectedCard?.card.id === card.id}
                    />
                  </div>
                ))}
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}
