<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paci√™ncia - Alanna ‚ô•</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 10px rgba(236, 72, 153, 0.5); border-color: #ec4899 !important; }
      50% { box-shadow: 0 0 20px rgba(236, 72, 153, 0.8); }
    }
    /* Adicione/Substitua dentro da tag <style> */
    body {
      touch-action: manipulation; /* Melhora o toque no celular */
      overflow-x: hidden;
      background-attachment: fixed;
    }

    #root {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Ajuste para telas pequenas n√£o cortarem as colunas */
    @media (max-width: 768px) {
      .max-w-4xl {
        max-width: 100%;
        padding: 0 5px;
      }
      /* Diminui levemente o tamanho das cartas se a tela for pequena */
      .w-20 { width: 4.5rem; }
      .h-28 { height: 6.3rem; }
    }
    
    .valid-drop {
      animation: pulse-glow 1.5s ease-in-out infinite;
    }
    
    @keyframes card-move {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .card-moving {
      animation: card-move 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .fade-in {
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .slide-up {
      animation: slideUp 0.4s ease;
    }
    @media (max-width: 640px) {
  .text-sm { font-size: 0.7rem !important; }
  .text-xs { font-size: 0.6rem !important; }
  /* Ajusta o tamanho dos naipes nas cartas para n√£o estourarem */
  .card-suit { font-size: 1.2rem; }
}
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    const SUITS = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
    const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    
    const DIFFICULTIES = {
      easy: { name: 'F√°cil', draw: 1, desc: 'Perfeito para come√ßar' },
      medium: { name: 'M√©dio', draw: 3, desc: 'Um desafio equilibrado' },
      hard: { name: 'Dif√≠cil', draw: 3, desc: 'Para mestres da paci√™ncia' }
    };

    const PHOTOS = {
      jack: './images/jack.png',
      queen: './images/queen.png',
      king: './images/king.png',
      hearts: './images/hearts.png',
      diamonds: './images/diamonds.png',
      clubs: './images/clubs.png',
      spades: './images/spades.png'
    };

    // √çcones SVG
    const RotateCcw = () => (<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M1 4v6h6M23 20v-6h-6"/><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"/></svg>);
    const Trophy = ({ className }) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>);
    const Clock = ({ className }) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>);
    const Heart = ({ className }) => (<svg className={className} viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg>);
    const Sparkles = ({ className }) => (<svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 3v18M3 12h18M6.5 6.5l11 11M17.5 6.5l-11 11"/></svg>);
    const UndoIcon = () => (<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>);
    const RestartIcon = () => (<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>);
    const ShuffleIcon = () => (<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5"/></svg>);
    const RefreshIcon = () => (<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>);

    const createDeck = () => {
      const deck = [];
      SUITS.forEach(suit => {
        RANKS.forEach((rank, i) => {
          deck.push({
            suit,
            rank,
            value: i + 1,
            color: (suit === '‚ô•' || suit === '‚ô¶') ? 'red' : 'black',
            id: `${suit}-${rank}`
          });
        });
      });
      return deck;
    };

    const shuffleDeck = (deck) => {
      const shuffled = [...deck];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    };

    function SolitaireGame() {
      // Tenta ler o jogo salvo na mem√≥ria do navegador
      const savedGame = JSON.parse(localStorage.getItem('pacienciaAlannaData'));

      // Se existir jogo salvo, usa os dados dele. Se n√£o, usa o padr√£o (menu, easy, arrays vazios...)
      const [gameState, setGameState] = useState(savedGame ? 'playing' : 'menu');
      const [difficulty, setDifficulty] = useState(savedGame?.difficulty || 'easy');
      const [tableau, setTableau] = useState(savedGame?.tableau || []);
      const [foundations, setFoundations] = useState(savedGame?.foundations || [[], [], [], []]);
      const [stock, setStock] = useState(savedGame?.stock || []);
      const [waste, setWaste] = useState(savedGame?.waste || []);
      const [score, setScore] = useState(savedGame?.score || 0);
      const [moves, setMoves] = useState(savedGame?.moves || 0);
      const [time, setTime] = useState(savedGame?.time || 0);
      const [history, setHistory] = useState(savedGame?.history || []);
      
      // Estados visuais (n√£o precisam ser salvos)
      const [selectedCard, setSelectedCard] = useState(null);
      const [isRunning, setIsRunning] = useState(savedGame ? true : false); 
      const [validDropZones, setValidDropZones] = useState([]);
      const [draggedCard, setDraggedCard] = useState(null);
      const [lastClickTime, setLastClickTime] = useState(0);
      const [animatingCard, setAnimatingCard] = useState(null);
      
      // Salva o estado sempre que algo importante mudar
      useEffect(() => {
        if (gameState === 'playing') {
          const gameData = {
            tableau, foundations, stock, waste, 
            score, moves, time, difficulty, history
          };
          localStorage.setItem('pacienciaAlannaData', JSON.stringify(gameData));
        }
      }, [tableau, foundations, stock, waste, score, moves, time, difficulty, history, gameState]);

      useEffect(() => {
        let interval;
        if (isRunning) {
          interval = setInterval(() => {
            setTime(t => t + 1);
          }, 1000);
        }
        return () => clearInterval(interval);
      }, [isRunning]);

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const saveHistory = () => {
        setHistory(prev => [...prev, {
          tableau: JSON.parse(JSON.stringify(tableau)),
          foundations: JSON.parse(JSON.stringify(foundations)),
          stock: [...stock],
          waste: [...waste],
          score,
          moves
        }]);
      };

      const startGame = (diff) => {
        setDifficulty(diff);
        const deck = shuffleDeck(createDeck());
        setHistory([]);
        const newTableau = [[], [], [], [], [], [], []];
        let deckIndex = 0;
        for (let col = 0; col < 7; col++) {
          for (let row = 0; row <= col; row++) {
            newTableau[col].push({
              ...deck[deckIndex],
              faceUp: row === col
            });
            deckIndex++;
          }
        }
        
        setTableau(newTableau);
        setFoundations([[], [], [], []]);
        setStock(deck.slice(deckIndex));
        setWaste([]);
        setSelectedCard(null);
        setScore(0);
        setMoves(0);
        setTime(0);
        setIsRunning(true);
        setGameState('playing');
        setValidDropZones([]);
      };

      const drawFromStock = () => {
        saveHistory();
        const drawCount = DIFFICULTIES[difficulty].draw;
        if (stock.length === 0) {
          const newStock = [...waste].reverse().map(card => ({ ...card, faceUp: false }));
          setStock(newStock);
          setWaste([]);
          return;
        }

        const drawn = stock.slice(0, Math.min(drawCount, stock.length)).map(card => ({ ...card, faceUp: true }));
        setWaste([...waste, ...drawn]);
        setStock(stock.slice(drawn.length));
        setMoves(m => m + 1);
      };

      const recycleWaste = () => {
        if (waste.length === 0) return;
        saveHistory();
        const shuffledWaste = shuffleDeck([...waste]);
        const newStock = shuffledWaste.map(card => ({ ...card, faceUp: false }));
        
        setStock([...stock, ...newStock]);
        setWaste([]);
        setScore(s => Math.max(0, s - 15));
        setMoves(m => m + 1);
      };

      const canPlaceOnFoundation = (card, foundation) => {
        if (foundation.length === 0) {
          return card.rank === 'A';
        }
        const topCard = foundation[foundation.length - 1];
        return card.suit === topCard.suit && card.value === topCard.value + 1;
      };

      // CORRE√á√ÉO: Valida√ß√£o estrita para o Tableau
      const canPlaceOnTableau = (card, column) => {
        if (column.length === 0) {
          return card.rank === 'K';
        }
        const topCard = column[column.length - 1];
        
        // Garante que s√≥ move se a carta de destino estiver virada para cima
        if (!topCard.faceUp) return false;

        // Verifica cores opostas e valor decrescente
        const isOppositeColor = card.color !== topCard.color;
        const isDescendingValue = card.value === topCard.value - 1;

        return isOppositeColor && isDescendingValue;
      };

      const calculateValidDropZones = (card, location) => {
        const zones = [];
        foundations.forEach((foundation, idx) => {
          if (canPlaceOnFoundation(card, foundation)) {
            zones.push({ type: 'foundation', index: idx });
          }
        });
        tableau.forEach((column, idx) => {
          if (canPlaceOnTableau(card, column)) {
            zones.push({ type: 'tableau', index: idx });
          }
        });
        return zones;
      };

      const moveToFoundation = (card, fromLocation) => {
        const suitToFoundation = { '‚ô•': 0, '‚ô¶': 1, '‚ô£': 2, '‚ô†': 3 };
        const foundationIndex = suitToFoundation[card.suit];
        const foundation = foundations[foundationIndex];

        if (!canPlaceOnFoundation(card, foundation)) {
          return false;
        }
        
        saveHistory();
        setAnimatingCard(card.id);
        setTimeout(() => setAnimatingCard(null), 300);

        const newFoundations = [...foundations];
        newFoundations[foundationIndex] = [...newFoundations[foundationIndex], card];
        setFoundations(newFoundations);

        if (fromLocation.type === 'waste') {
          setWaste(waste.slice(0, -1));
        } else if (fromLocation.type === 'tableau') {
          const newTableau = [...tableau];
          newTableau[fromLocation.column] = newTableau[fromLocation.column].slice(0, -1);
          if (newTableau[fromLocation.column].length > 0) {
            newTableau[fromLocation.column][newTableau[fromLocation.column].length - 1].faceUp = true;
          }
          setTableau(newTableau);
        }

        setScore(s => s + 10);
        setMoves(m => m + 1);
        setSelectedCard(null);
        setValidDropZones([]);
        
        if (newFoundations.every(f => f.length === 13)) {
          setIsRunning(false);
          setGameState('won');
        }
        return true;
      };

      const handleCardClick = (card, location) => {
        if (!card.faceUp) return;

        const currentTime = Date.now();
        const timeDiff = currentTime - lastClickTime;

        // Double click detection (< 300ms)
        if (timeDiff < 300 && selectedCard?.card.id === card.id) {
          const moved = moveToFoundation(card, location);
          if (!moved) {
            const validZones = calculateValidDropZones(card, location);
            if (validZones.length > 0) {
              const firstTableauZone = validZones.find(z => z.type === 'tableau');
              if (firstTableauZone) {
                handleTableauMove(card, location, firstTableauZone.index);
              }
            }
          }
          setLastClickTime(0);
          return;
        }
        
        setLastClickTime(currentTime);

        if (selectedCard) {
          if (selectedCard.location.type === 'waste' || selectedCard.location.type === 'tableau') {
            if (location.type === 'tableau') {
              handleTableauMove(selectedCard.card, selectedCard.location, location.column);
              return;
            }
          }
          setSelectedCard(null);
          setValidDropZones([]);
        } else {
          setSelectedCard({ card, location });
          const zones = calculateValidDropZones(card, location);
          setValidDropZones(zones);
        }
      };

      // CORRE√á√ÉO: Fun√ß√£o melhorada para lidar com movimento de pilhas
      const handleTableauMove = (card, fromLocation, toColumn) => {
        const column = tableau[toColumn];
        
        // Se a origem e o destino forem a mesma coluna, cancela
        if (fromLocation.type === 'tableau' && fromLocation.column === toColumn) {
          setSelectedCard(null);
          setValidDropZones([]);
          return;
        }

        if (!canPlaceOnTableau(card, column)) return;
        
        saveHistory();
        setAnimatingCard(card.id);
        setTimeout(() => setAnimatingCard(null), 300);
        
        const newTableau = [...tableau];
        
        if (fromLocation.type === 'waste') {
          // Movendo do lixo para a mesa
          newTableau[toColumn] = [...newTableau[toColumn], { ...card, faceUp: true }];
          setWaste(waste.slice(0, -1));
        } else {
          // Movendo entre colunas da mesa (Mec√¢nica de Pilhas)
          const fromCol = fromLocation.column;
          // Encontra onde a carta clicada est√° na pilha
          const cardIndex = newTableau[fromCol].findIndex(c => c.id === card.id);
          
          if (cardIndex !== -1) {
            // Pega a carta clicada e TODAS as que est√£o abaixo dela
            const cardsToMove = newTableau[fromCol].slice(cardIndex);
            
            // Adiciona a pilha inteira na nova coluna
            newTableau[toColumn] = [...newTableau[toColumn], ...cardsToMove];
            
            // Remove as cartas da coluna antiga
            newTableau[fromCol] = newTableau[fromCol].slice(0, cardIndex);
            
            // Vira a nova carta do topo da coluna antiga, se houver
            if (newTableau[fromCol].length > 0) {
              newTableau[fromCol][newTableau[fromCol].length - 1].faceUp = true;
            }
          }
        }
        
        setTableau(newTableau);
        setScore(s => s + 5);
        setMoves(m => m + 1);
        setSelectedCard(null);
        setValidDropZones([]);
      };

      const handleFoundationClick = (index) => {
        if (selectedCard) {
          moveToFoundation(selectedCard.card, selectedCard.location);
        }
      };
      const handleEmptyTableauClick = (colIndex) => {
        if (selectedCard && selectedCard.card.rank === 'K') {
          handleTableauMove(selectedCard.card, selectedCard.location, colIndex);
        }
      };

      const handleEmptyTableauClick = (colIndex) => {
        if (selectedCard && selectedCard.card.rank === 'K') {
          handleTableauMove(selectedCard.card, selectedCard.location, colIndex);
        }
      };

      const handleDragStart = (e, card, location) => {
        if (!card.faceUp) {
          e.preventDefault();
          return;
        }
        setDraggedCard({ card, location });
        const zones = calculateValidDropZones(card, location);
        setValidDropZones(zones);
        e.dataTransfer.effectAllowed = 'move';
      };

      const handleDragOver = (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      };

      const handleDrop = (e, dropLocation) => {
        e.preventDefault();
        if (!draggedCard) return;

        if (dropLocation.type === 'foundation') {
          moveToFoundation(draggedCard.card, draggedCard.location);
        } else if (dropLocation.type === 'tableau') {
          handleTableauMove(draggedCard.card, draggedCard.location, dropLocation.column);
        }

        setDraggedCard(null);
        setValidDropZones([]);
      };

      const handleDragEnd = () => {
        setDraggedCard(null);
        setValidDropZones([]);
      };

      const undoMove = () => {
        if (history.length === 0) return;
        const previousState = history[history.length - 1];
        const newHistory = history.slice(0, -1);

        setTableau(previousState.tableau);
        setFoundations(previousState.foundations);
        setStock(previousState.stock);
        setWaste(previousState.waste);
        setScore(previousState.score);
        setMoves(previousState.moves);
        setHistory(newHistory);
        setValidDropZones([]);
        setSelectedCard(null);
      };

      const restartGame = () => {
        if (history.length === 0) return;
        const initialState = history[0];
        
        setTableau(initialState.tableau);
        setFoundations(initialState.foundations);
        setStock(initialState.stock);
        setWaste(initialState.waste);
        setScore(initialState.score);
        setMoves(0);
        setTime(0);
        setHistory([]);
        setValidDropZones([]);
        setSelectedCard(null);
      };

     const handleNewGame = () => {
        localStorage.removeItem('pacienciaAlannaData'); // Adicione esta linha
        startGame(difficulty);
      };

      const isValidDropZone = (type, index) => {
        return validDropZones.some(zone => zone.type === type && zone.index === index);
      };

      const Card = ({ card, onClick, isSelected, onDragStart, style = {} }) => {
        const isRed = card.color === 'red';
        const isAnimating = animatingCard === card.id;
        
        const getCardPhoto = () => {
          if (card.rank === 'J') return PHOTOS.jack;
          if (card.rank === 'Q') return PHOTOS.queen;
          if (card.rank === 'K') return PHOTOS.king;
          const suitMap = { '‚ô•': 'hearts', '‚ô¶': 'diamonds', '‚ô£': 'clubs', '‚ô†': 'spades' };
          return PHOTOS[suitMap[card.suit]];
        };

        const shouldShowPhoto = card.faceUp;
        const photo = shouldShowPhoto ? getCardPhoto() : null;
        
        return (
          <div
            draggable={card.faceUp}
            onClick={onClick}
            onDragStart={onDragStart}
            onDragEnd={handleDragEnd}
            sm:w-20 significa que em telas maiores (PC) volta a ser o tamanho fixo padr√£o. */
            className={`relative w-[12.5vw] h-[17.5vw] sm:w-20 sm:h-28 rounded-lg flex flex-col items-center justify-center text-xs sm:text-sm font-bold cursor-pointer transition-all shadow-md overflow-hidden select-none
              ${card.faceUp 
                ? `bg-white ${card.color === 'red' ? 'text-red-500' : 'text-gray-900'} ${isSelected ? 'ring-2 ring-pink-500 scale-105 z-50' : 'border border-gray-300'}` 
                : 'bg-gradient-to-br from-purple-600 to-rose-500 border border-white/20'}
            `}
            style={{ ...style, zIndex: isSelected ? 100 : 'auto' }}
          >
            {card.faceUp ? (
              <>
                {photo ? (
                  <>
                    <img 
                      src={photo} 
                      alt={card.rank}
                      className="absolute inset-0 w-full h-full object-cover"
                    />
                    <div className="absolute top-1 left-1 bg-white bg-opacity-90 rounded px-1.5 py-0.5 text-xs font-bold shadow-sm">
                      {card.rank}
                    </div>
                    <div className={`absolute top-1 right-1 bg-white bg-opacity-90 rounded px-1 py-0.5 text-base shadow-sm ${isRed ? 'text-red-500' : 'text-gray-800'}`}>
                      {card.suit}
                    </div>
                  </>
                ) : (
                  <>
                    <div className="text-xl font-bold">{card.rank}</div>
                    <div className="text-2xl">{card.suit}</div>
                  </>
                )}
              </>
            ) : (
              <div className="w-full h-full flex items-center justify-center">
                <div className="text-white opacity-30 text-3xl">‚ú¶</div>
              </div>
            )}
          </div>
        );
      };

      if (gameState === 'menu') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-rose-400 via-pink-400 to-purple-500 flex items-center justify-center p-4">
            <div className="absolute inset-0 overflow-hidden pointer-events-none">
              <div className="absolute top-20 left-10 text-6xl opacity-10">‚ô•</div>
              <div className="absolute top-40 right-20 text-5xl opacity-10">‚ô¶</div>
              <div className="absolute bottom-32 left-20 text-7xl opacity-10">‚ô†</div>
              <div className="absolute bottom-20 right-32 text-6xl opacity-10">‚ô£</div>
            </div>
            
            <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full relative z-10 fade-in">
              <div className="text-center mb-8">
                <Sparkles className="w-12 h-12 mx-auto mb-3 text-pink-500" />
                <h1 className="text-5xl font-bold mb-2 bg-gradient-to-r from-pink-500 via-rose-500 to-purple-500 bg-clip-text text-transparent">
                  Paci√™ncia
                </h1>
                <div className="flex items-center justify-center gap-2 mb-1">
                  <Heart className="w-5 h-5 text-rose-500 fill-rose-500" />
                  <p className="text-2xl font-semibold text-gray-700">Alanna</p>
                  <Heart className="w-5 h-5 text-rose-500 fill-rose-500" />
                </div>
                <p className="text-sm text-gray-500 italic">Feito especialmente para voc√™</p>
              </div>
              
              <div className="space-y-3">
                <h2 className="text-lg font-semibold text-gray-700 text-center mb-4">
                  Escolha sua dificuldade
                </h2>
                
                {Object.entries(DIFFICULTIES).map(([key, { name, desc }]) => (
                  <button
                    key={key}
                    onClick={() => startGame(key)}
                    className="w-full bg-gradient-to-r from-pink-500 to-rose-500 hover:from-pink-600 hover:to-rose-600 text-white font-semibold py-4 px-6 rounded-xl transition-all transform hover:scale-105 shadow-lg hover:shadow-xl"
                  >
                    <div className="text-lg">{name}</div>
                    <div className="text-xs opacity-90">{desc}</div>
                  </button>
                ))}
              </div>
              
              <div className="mt-6 text-center text-xs text-gray-400">
                ‚ô• Toque ou arraste as cartas para jogar ‚ô•
              </div>
            </div>
          </div>
        );
      }

      if (gameState === 'won') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-yellow-400 via-orange-400 to-pink-500 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-lg w-full text-center fade-in">
              <Trophy className="w-28 h-28 mx-auto mb-4 text-yellow-500 animate-bounce" />
              <h1 className="text-5xl font-bold mb-2 bg-gradient-to-r from-yellow-500 to-orange-500 bg-clip-text text-transparent">
                Parab√©ns!
              </h1>
              <p className="text-3xl mb-4">üéâ</p>
              
              <div className="bg-gradient-to-r from-pink-50 to-purple-50 rounded-2xl p-6 mb-6">
                <p className="text-lg leading-relaxed text-gray-700 mb-4">
                  <span className="font-bold text-pink-600">Parab√©ns, minha princesa!</span> Eu sabia que ia conseguir. 
                  <span className="text-rose-600 font-semibold"> Eu te amo mais do que tudo.</span> Voc√™ √© muito forte, muito mais do que imagina.
                  Tudo isso vai passar, eu estou aqui pra te ajudar, aqui por voc√™.
                  <span className="text-purple-600 font-semibold"> Eu te amo, minha princesa, minha rosa azul, minha noiva, minha Alanna.</span>
                </p>
              </div>
              
              <div className="bg-gradient-to-r from-pink-50 to-purple-50 rounded-2xl p-5 mb-6 space-y-3">
                <div className="text-lg">
                  <span className="font-semibold text-gray-700">Movimentos:</span>{' '}
                  <span className="text-purple-600 font-bold text-xl">{moves}</span>
                </div>
                <div className="text-lg">
                  <span className="font-semibold text-gray-700">Tempo:</span>{' '}
                  <span className="text-rose-600 font-bold text-xl">{formatTime(time)}</span>
                </div>
              </div>

              <button
                onClick={() => {
                  localStorage.removeItem('pacienciaAlannaData'); // Adicione aqui
                  setGameState('menu');
                }}
                className="w-full bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white font-semibold py-4 px-6 rounded-xl transition-all transform hover:scale-105 shadow-lg"
              >
                Jogar Novamente
              </button>
            </div>
          </div>
        );
      }

      const foundationSuits = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];

      // RENDERIZA√á√ÉO CORRIGIDA - Sem texto duplicado
     return (
        <div className="min-h-screen bg-gradient-to-br from-rose-400 via-pink-500 to-purple-600 p-2 sm:p-4 font-sans select-none overflow-x-hidden">
          <div className="max-w-4xl mx-auto game-container">
            
            {/* Header: Placar e Tempo */}
            <div className="flex justify-between items-center mb-4 bg-white bg-opacity-20 backdrop-blur-lg p-3 rounded-2xl shadow-lg border border-white border-opacity-30">
              <div className="flex gap-4 sm:gap-8 font-bold text-white text-sm sm:text-base">
                <div className="flex flex-col items-center">
                  <span className="text-[10px] uppercase opacity-80">Tempo</span>
                  <span>‚è± {Math.floor(time / 60)}:{(time % 60).toString().padStart(2, '0')}</span>
                </div>
                <div className="flex flex-col items-center">
                  <span className="text-[10px] uppercase opacity-80">Pontos</span>
                  <span>‚≠ê {score}</span>
                </div>
              </div>
              <div className="flex gap-2">
                <button onClick={undoMove} className="p-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-xl text-white transition-all shadow-inner" title="Desfazer">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
                </button>
                <button onClick={handleNewGame} className="p-2 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-xl text-white transition-all shadow-inner" title="Novo Jogo">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>
                </button>
              </div>
            </div>

            {/* Top Row: Monte e Funda√ß√µes */}
            <div className="flex justify-between mb-4 sm:mb-8 px-1">
              <div className="flex gap-2">
                <div 
                  onClick={drawFromStock}
                  className={`w-[13vw] h-[18vw] sm:w-20 sm:h-28 rounded-lg border-2 border-white shadow-lg cursor-pointer flex items-center justify-center transition-all active:scale-95 ${stock.length > 0 ? 'bg-gradient-to-br from-pink-500 to-rose-600' : 'bg-pink-200 opacity-50'}`}
                >
                  {stock.length > 0 && <span className="text-white opacity-40 text-xl">‚ú¶</span>}
                </div>

                <div className="w-[13vw] h-[18vw] sm:w-20 sm:h-28 rounded-lg border-2 border-dashed border-pink-200 bg-pink-50/30">
                  {waste.length > 0 && (
                    <Card 
                      card={waste[waste.length - 1]} 
                      onClick={() => handleCardClick(waste[waste.length - 1], { type: 'waste' })}
                      onDragStart={(e) => handleDragStart(e, waste[waste.length - 1], { type: 'waste' })}
                      isSelected={selectedCard?.card.id === waste[waste.length - 1].id}
                    />
                  )}
                </div>
              </div>

              <div className="flex gap-1 sm:gap-2">
                {foundations.map((foundation, i) => (
                  <div 
                    key={i}
                    onDragOver={handleDragOver}
                    onDrop={(e) => handleDrop(e, { type: 'foundation', index: i })}
                    className="w-[13vw] h-[18vw] sm:w-20 sm:h-28 rounded-lg border-2 border-dashed border-pink-200 bg-pink-50/30 flex items-center justify-center"
                  >
                    {foundation.length > 0 ? (
                      <Card 
                        card={foundation[foundation.length - 1]} 
                        onClick={() => handleCardClick(foundation[foundation.length - 1], { type: 'foundation', index: i })}
                        onDragStart={(e) => handleDragStart(e, foundation[foundation.length - 1], { type: 'foundation', index: i })}
                        isSelected={selectedCard?.card.id === foundation[foundation.length - 1].id}
                      />
                    ) : (
                      <span className="text-pink-200 text-xl">{['‚ô•', '‚ô¶', '‚ô£', '‚ô†'][i]}</span>
                    )}
                  </div>
                ))}
              </div>
            </div>

            {/* Tableau: Colunas do Jogo */}
            <div className="flex gap-1 sm:gap-4 justify-center w-full px-1 sm:px-0 mt-2">
              {tableau.map((column, colIndex) => (
                <div key={colIndex} className="relative w-[13vw] sm:w-20 flex flex-col items-center">
                  <div
                    onClick={() => column.length === 0 && handleEmptyTableauClick(colIndex)}
                    onDragOver={handleDragOver}
                    onDrop={(e) => handleDrop(e, { type: 'tableau', column: colIndex })}
                    className={`w-[13vw] h-[18vw] sm:w-20 sm:h-28 rounded-lg border-2 border-dashed border-pink-200 bg-pink-50/50 mb-1 ${
                      column.length === 0 && isValidDropZone('tableau', colIndex) ? 'valid-drop' : ''
                    }`}
                  />
                  {column.map((card, cardIndex) => (
                    <div
                      key={card.id}
                      style={{ 
                        marginTop: cardIndex === 0 ? '-18vw' : '-14vw', 
                        position: 'relative',
                        zIndex: cardIndex + 1 
                      }}
                      className="sm:-mt-20"
                      onDragOver={handleDragOver}
                      onDrop={(e) => handleDrop(e, { type: 'tableau', column: colIndex })}
                    >
                      <Card
                        card={card}
                        onClick={() => handleCardClick(card, { type: 'tableau', column: colIndex })}
                        onDragStart={(e) => handleDragStart(e, card, { type: 'tableau', column: colIndex })}
                        isSelected={selectedCard?.card.id === card.id}
                      />
                    </div>
                  ))}
                </div>
              ))}
            </div>

            <div className="mt-8 text-center text-sm text-white bg-white bg-opacity-20 backdrop-blur rounded-xl p-3">
              <p className="font-semibold italic text-[10px] sm:text-xs">üí° Dica: Clique duas vezes para movimento autom√°tico!</p>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<SolitaireGame />, document.getElementById('root'));
  </script>
</body>
</html>
